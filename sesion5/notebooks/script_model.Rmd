---
title: "Ejemplo: Credit Scoring"
author: "Sherly Tarazona"
date: "`r Sys.Date()`"
theme: bootstrap
output:
  html_document:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    number_sections: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, echo=FALSE}
<style>
pre {
  white-space: pre !important;
  overflow-y: scroll !important;
  height: 50vh !important;
}
</style>
```

```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;-
}

pre[class] {
  max-height: 100px;
}
```



```{r, echo=F, results='hide',message=FALSE, eval=T,warning=FALSE}

#Libro Rmarkdown: https://bookdown.org/yihui/rmarkdown-cookbook/tables.html

# Librerias
#install.packages("precrec")
library(precrec)
library(ROCit)
library(stringr)
library(sqldf)
library(dplyr)
library(tidyr)
library(readxl)
library(lubridate)
library(ggplot2)
library(ggpubr)
library(scorecard)
library(Information)
library(mlr)
library(pROC)
#library(caret)
library(htmltools)
library(arrow)
library(tidyverse)
library(qs)
library(naniar)
library(xlsx)
options(scipen=999)

```



```{r, echo=F, eval=T}
##==============
## Funciones 
##==============

#######################################
# AUC, Gini - Logit
#######################################

auc_gini<-function(muestra,modelo){
  pred<-predict(modelo,muestra,type = "response")
  auc=round(roc(muestra$target_y,pred)$auc,2)
  gini=round(2*auc-1,2)  
  cbind(auc,gini)
}

#===============
#AUC, Gini - RF
auc_gini_rf<-function(muestra,modelo){
pred<- predict(modelo, muestra, type="prob")
auc=round(roc(muestra$target_y,pred[,2])$auc,2)
gini=round(2*auc-1,2)  
cbind(auc,gini)
}

#######################################
# Tabla de validacion: ordenamiento
#######################################

tabla_validacion<-function(muestra,n_division,modelo){
  
  muestra$prob_m<-predict(modelo,muestra,type = "response")
  muestra$prob_m_cut<- cut(muestra$prob_m, quantile(na.omit(muestra$prob_m),(0:n_division)/n_division),include.lowest = TRUE)
  
  a=round(prop.table(table(muestra$prob_m_cut,muestra$target_y),margin=1),4)
  b=table(muestra$prob_m_cut,muestra$target_y)
  c=cbind("Buenos"=b[,1],"Malos"=b[,2],"Total"=(b[,1]+b[,2]),"%Tasa de Malos"=a[,2]*100)
  knitr::kable(c, align = "cccc")
}

tabla_validacion_plot<-function(muestra,n_division,modelo){
  
  muestra$prob_m<-predict(modelo,muestra,type = "response")
  muestra$prob_m_cut<- cut(muestra$prob_m, quantile(na.omit(muestra$prob_m),(0:n_division)/n_division),include.lowest = TRUE)
  #muestra$prob_m_cut<-ntile(muestra$prob_m, 10)
  data<-    muestra %>%
    select(prob_m,prob_m_cut,target_y) %>%
    group_by(prob_m_cut,target_y) %>%
    summarise(Total = n()) %>%
    pivot_wider(names_from = target_y, values_from = Total) %>%
    rename(Buenos=`0`, Malos=`1`,Deciles=prob_m_cut) %>%
    mutate( Total=Buenos+Malos
            ,`%Tasa_de_malos` = Malos*100/sum(Total))
  
  ggplot(data, aes(x=Deciles, y=`%Tasa_de_malos`, group=1))+
    geom_point(colour="steelblue", size=2) +
    geom_line(size=1.5, colour="steelblue")+
    labs(y = "%Tasa de Malos", 
         x = "Cortes de probabilidad",
         title = "%Tasa de Malos por cortes de probabilidad",
         subtitle = "Comportamiento esperado: A mayor probabilidad, mayor % de malos")+
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))+
    theme(legend.position = "bottom")+
    theme(axis.text.x = element_text(angle=90))
}  

#========================
#Incluido indeterminados

tabla_validacion_det<-function(muestra,n_division,modelo){
  muestra$target_y<-ifelse(muestra$target_y==2,0,muestra$target_y)
  muestra$prob_m_cut<- cut(muestra$prob_m,  quantile(na.omit(muestra$prob_m),(0:n_division)/n_division),include.lowest = TRUE)
  
  a=round(prop.table(table(muestra$prob_m_cut,muestra$target_y),margin=1),4)
  b=table(muestra$prob_m_cut,muestra$target_y)
  c=cbind("Buenos"=b[,1],"Malos"=b[,2],"Total"=(b[,1]+b[,2]),"%Tasa de Malos"=a[,2]*100)
  knitr::kable(c, align = "cccc")
}


tabla_validacion_plot_det<-function(muestra,n_division,modelo){
  muestra$target_y<-ifelse(muestra$target_y==2,0,muestra$target_y)
  muestra$prob_m_cut<- cut(muestra$prob_m, quantile(na.omit(muestra$prob_m),(0:n_division)/n_division),include.lowest = TRUE)
  #muestra$prob_m_cut<-ntile(muestra$prob_m, 10)
  data<-    muestra %>%
    select(prob_m,prob_m_cut,target_y) %>%
    group_by(prob_m_cut,target_y) %>%
    summarise(Total = n()) %>%
    pivot_wider(names_from = target_y, values_from = Total) %>%
    rename(Buenos=`0`, Malos=`1`,Deciles=prob_m_cut) %>%
    mutate( Total=Buenos+Malos
            ,`%Tasa_de_malos` = Malos*100/sum(Total))
  
  ggplot(data, aes(x=Deciles, y=`%Tasa_de_malos`, group=1))+
    geom_point(colour="steelblue", size=2) +
    geom_line(size=1.5, colour="steelblue")+
    labs(y = "%Tasa de Malos", 
         x = "Cortes de probabilidad",
         title = "%Tasa de Malos por cortes de probabilidad - incluido indeterminados",
         subtitle = "Comportamiento esperado: A mayor probabilidad, mayor % de malos")+
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))+
    theme(legend.position = "bottom")+
    theme(axis.text.x = element_text(angle=90))
}  


#######################################
# Grafico de correlacion
#######################################

grafico_correlacion<-function(variables,muestra){
  
  library(reshape2)
  library(ggplot2)
  
  cormat<-cor(as.data.frame(muestra)[,variables])
  cormat<-round(cormat,1)
  #melted_cormat <- melt(round(cormat,2))
  
  # Get lower triangle of the correlation matrix
  get_lower_tri<-function(cormat){
    cormat[upper.tri(cormat)] <- NA
    return(cormat)
  }
  # Get upper triangle of the correlation matrix
  get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
  }
  reorder_cormat <- function(cormat){
    # Use correlation between variables as distance
    dd <- as.dist((1-cormat)/2)
    hc <- hclust(dd)
    cormat <-cormat[hc$order, hc$order]
  }
  
  # Reorder the correlation matrix
  cormat <- reorder_cormat(cormat)
  upper_tri <- get_upper_tri(cormat)
  # Melt the correlation matrix
  melted_cormat <- melt(upper_tri, na.rm = TRUE)
  # Create a ggheatmap
  ggheatmap <- 
    ggplot(melted_cormat, aes(Var2, Var1, fill = value))+
    geom_tile(color = "white")+
    scale_fill_gradient2(low = "deeppink", high = "steelblue", mid = "white", 
                         midpoint = 0, limit = c(-1,1), space = "Lab", 
                         name="Pearson/Correlation") +
    theme_minimal()+ # minimal theme
    theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                     size = 12, hjust = 1))+
    labs(title = "Correlaciones")+
    theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))+
    coord_fixed()
  # Print the heatmap
  ggheatmap + 
    geom_text(aes(Var2, Var1, label = value), color = "black", size = 4) +
    
    theme(
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      panel.grid.major = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank(),
      axis.ticks = element_blank(),
      legend.justification = c(1, 0),
      legend.position = c(0.6, 0.7),
      legend.direction = "horizontal")+
    guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                                 title.position = "top", title.hjust = 0.5))    
}

#=========================
# ConfusionMatrix-metrics
#=========================
metrics_conf_matrix<-function(model_name,muestra,pto_cut){
  
  muestra$y_pred<-if_else(muestra$prob_m>pto_cut,1,0)
  #positivo: no formal
  #negativo: formal
  vn<-table(muestra$target_y,muestra$y_pred)[1]
  fn<-table(muestra$target_y,muestra$y_pred)[2]
  fp<-table(muestra$target_y,muestra$y_pred)[3]
  vp<-table(muestra$target_y,muestra$y_pred)[4]
  
  #metricas
  total<- vp+fp+fn+vn
  accuracy<-(vp+vn)/total
  error_rate<-(fp+fn)/total
  especificity<-vn/(fp+vn)
  sensitivity<-vp/(fn+vp)
  precision<-vp/(vp+fp)
  c<-data.frame(accuracy,error_rate,sensitivity,especificity,precision)
  rownames(c)<-model_name
  knitr::kable(c, align = "ccc")   
}

#==========
#Tabla ROC
#==========
roc_data <- function(model, muestra, step=0.01) {
  out<-data.frame()
  cut <- seq(step, 1, by = step)
  for (i in cut) {
  muestra$y_pred<-if_else(muestra$prob_m>i,1,0)
  
  vn<-table(muestra$target_y,muestra$y_pred)[1]
  fn<-table(muestra$target_y,muestra$y_pred)[2]
  fp<-table(muestra$target_y,muestra$y_pred)[3]
  vp<-table(muestra$target_y,muestra$y_pred)[4]
  
  #metrics
  accuracy<-(vp+vn)/total
  total<-vp+fp+fn+vn
  error_rate<-(fp+fn)/total
  especificity<-vn/(fp+vn)
  sensitivity<-vp/(fn+vp)
  precision<-vp/(vp+fp)
  
  out<-rbind(out,c(i,1-especificity,sensitivity,especificity,precision))
  }
  names(out)<-c("cut","menos1_Especificity","Sensivity","Especificity","Precision")
  return(out)
}

#=============
#GRAFICO ROC
#=============
auc_plt<-function(model,muestra){
  #Llama a la funcion roc_data
  roc_graph <- roc_data(model,muestra,step = 0.01)
  ggplot(roc_graph,aes(menos1_Especificity,Sensivity))+
  geom_point(colour="blue") +
  geom_line(size=1, colour="blue")+
  geom_text(aes(label = cut), 
            size = 3,
            vjust = 1.5,
            colour="black")+
  labs(y = "Sensibilidad", 
       x = "1-Especificidad",
       title = "Curva ROC")+
  theme(plot.title = element_text(hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5))+
  theme(legend.position = "bottom")
}

#==================================
#IMPORTANCIA DE VARIABLES - LOGIT
#==================================

plt_importance_logit<-function(model){
  
  a<-vif(model, merge_coef = TRUE)[,c("variable","z value")]
  a<-a[2:nrow(a),]
  b<-a[order(a$`z value`,decreasing=T),]
  n=nrow(b)
  total=sum(b$`z value`)
  contribution<-round(b[,2]*100/total,0)
  tb_union<-cbind(b,"contribution"=contribution)
  colnames(tb_union)<-c("variable","z value","% Contribución")
  tb_importance<-tb_union[,c(1,3)]
  #knitr::kable(tb_importance)
  
  tb_importance<-as.data.frame(tb_importance)
  tb_importance<-tb_importance %>% arrange(`% Contribución`)
  
  plt_imp<-tb_importance %>%
  mutate(name = fct_reorder(variable, `% Contribución`, .desc = F)) %>%
  ggplot(aes(x=name, y=`% Contribución`))+
  geom_bar(stat = "identity", fill="steelblue")+
  coord_flip()+
  theme_minimal()+
  geom_text(aes(label = `% Contribución`), 
            size = 3,
            vjust = 0.7,
            hjust = 0,
            colour="black")+
  labs(x = "Variables",
       title = "Porcentaje de contribución de variables",
       subtitle = "Datos expresados en porcentaje(%)") +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))+
  theme(legend.position = "bottom")+  
  theme(axis.ticks.x = element_blank(),
        axis.title.x = element_blank())+
  theme(axis.text.x = element_text(angle=90))

plt_imp
}

```



```{r, echo=FALSE, eval=T, message=F, error=F}
#====================================
#Lectura del dataset
#************************************

data<-read.csv("dataset_creditscoring.csv")

```



```{r,  echo=FALSE, eval=T, message=F, error=F}
#====================================
# Filtros del modelo
#************************************
#
data<-data %>% 
               filter(malo_sf_inicio=="pasa_filtros_sf"&
                      target_y %in% c(0,1)&
                      flag_ratios_aprobados==1&
                      AUDITADO_1_TOTAL_INGRESOS_BRUTOS>=1000&
                      AUDITADO_1_TOTAL_INGRESOS_BRUTOS<=30000&
                      tipocredito=='Colocacion'&
                      periodo<='201911')

```


## 1. Definición de malo

| Categoría     | Descripción  |
|:-----------------------------------|:-----------------------------------|
| Malo          | Presenta días de atraso mayor a 30 días o clasificación mayor a CPP o Refinanciado o castigado o reestructurado en los siguientes 3 meses|
| Bueno         | Se mantuvo en 0 días de atraso en los siguientes 3|
| Indeterminado | resto|

> Para fines de modelamiento los indeterminados serán excluidos del análisis, pero sí se aplicará el modelo sobre ellos.


## 2.Volumetrías {.sectionFormat .tabset .tabset-fade .tabset-pills}

### 2.1 Cantidad por periodo y target

```{r, echo=F}
b=table(data$periodo,data$target_y)
c=cbind("Buenos"=b[,1],"Malos"=b[,2],"Total"=(b[,1]+b[,2]))
knitr::kable(c, align = "ccc",digits = 3, format.args = list(big.mark = ",",
  scientific = FALSE))

```

### Tasa de malos

```{r, echo=F}
#Tabla
a=round(prop.table(table(data$periodo,data$target_y),margin=1),4)
b=table(data$periodo,data$target_y)
c=cbind("Buenos"=b[,1],"Malos"=b[,2],"Total"=(b[,1]+b[,2]),"TasaMalos%"=a[,2]*100)
knitr::kable(c, align = "cccc",digits = 3, format.args 
             
             = list(big.mark = ",",
  scientific = FALSE))
```


```{r, echo=F, eval=F}
#Periodo desarrollo vs periodo backtesting

data_model=subset(data,data$periodo<=201906)
backtest=subset(data,data$periodo>=201907)
#table(data_model$periodo)
#table(backtest$periodo)
rm(data)

```


```{r, eval=F, echo=F}
#Testing & training set
dt_list = split_df(data_model, y="target_y", ratio = c(0.7, 0.3), seed = 3000) #semilla
test<-dt_list$test
train<-dt_list$train
dim(train)
dim(test)

```

```{r, eval=F, echo=F}
qsave(train,"01data/train.qs")
qsave(test,"01data/test.qs")
qsave(backtest,"01data/backtest.qs")


```

```{r, eval=T, echo=F}
train<-qread("01data/train.qs",nthreads=4)
test<-qread("01data/test.qs",nthreads=4)
backtest<-qread("01data/backtest.qs",nthreads=4)

#Lectura
train<-as.data.frame(train)
test<-as.data.frame(test)
backtest<-as.data.frame(backtest)


```

### 2.3.Muestra: Train

```{r, eval=T, echo=T}
#train
a=round(prop.table(table(train$periodo,train$target_y),margin=1),4)
b=table(train$periodo,train$target_y)
c=cbind("Buenos"=b[,1],"Malos"=b[,2],"Total"=(b[,1]+b[,2]),"TasaMalos%"=a[,2]*100)
knitr::kable(c, align = "cccc",digits = 3, format.args = list(big.mark = ",",
  scientific = FALSE))


```

### 2.4 Train & Test

```{r}
#train
a=round(prop.table(table(train$periodo,train$target_y),margin=1),4)
b=table(train$periodo,train$target_y)
d1=cbind("Buenos"=b[,1],"Malos"=b[,2],"Total"=(b[,1]+b[,2]),"Tasa de malos%"=a[,2]*100)
#test
a=round(prop.table(table(test$periodo,test$target_y),margin=1),4)
b=table(test$periodo,test$target_y)
d2=cbind("Buenos"=b[,1],"Malos"=b[,2],"Total"=(b[,1]+b[,2]),"Tasa de malos%"=a[,2]*100)

rownames(d2) <- NULL

knitr::kables(
  list(
    knitr::kable(d1,caption = "Muestra: Train",align = "cccc",digits = 3, format.args = list(big.mark = ",",
  scientific = FALSE)),
    knitr::kable(d2,caption = "Muestra: Test",align = "cccc",digits = 3, format.args = list(big.mark = ",",
  scientific = FALSE))
      ),
  caption = 'Distribucion por muestras'
  
)

```

### 2.5 Backtest

```{r}
a=round(prop.table(table(backtest$periodo,backtest$target_y),margin=1),4)
b=table(backtest$periodo,backtest$target_y)
c=cbind("Buenos"=b[,1],"Malos"=b[,2],"Total"=(b[,1]+b[,2]),"Tasa de malos%"=a[,2]*100)
knitr::kable(c, align = "cccc",digits = 3, format.args = list(big.mark = ",",
  scientific = FALSE))

```

### 2.6 Resumen %Malos por muestra

```{r}
a<-round(prop.table(table(train$target_y))*100,2)
b<-round(prop.table(table(test$target_y))*100,2)
c<-round(prop.table(table(backtest$target_y))*100,2)
d<-rbind(a,b,c)
rownames(d)<-c("train","test","backtest")
colnames(d)<-c("%Buenos","%Malos")
knitr::kable(d, align = "cc")

```

## 3.Análisis univariado y bivariado {.sectionFormat .tabset .tabset-fade .tabset-pills}

### 3.1 Univariado

```{r, echo=F, eval=F}
#==========================
# Univariados
#==========================

univariate<-data.frame(summarizeColumns(select(train,
                -periodo, -target_y)))

#Decision
univariate <- univariate %>% rename(Variable = name)

#IV referencial

IV <- Information::create_infotables(data=select(train, -periodo)
                                     , y="target_y"
                                     , parallel=FALSE)
tb_iv<-as.data.frame(IV$Summary)

#Tabla resumen da variables

tb_features<-merge(univariate,tb_iv,by = c('Variable'),all.x=TRUE)
write.csv(tb_features,"03reports/tb_features_resumen.csv",row.names = F)

```

```{r}
univ<-read.csv("03reports/tb_features_resumen.csv")
rmarkdown::paged_table(univ)
```


```{r, eval=T, echo=F, message=F, error=F,warning=FALSE,results='hide'}

#==========================
# Bivariados INICIALES
#==========================

#Github: https://github.com/ShichenXie/scorecard

selected<-c(

 "periodo"
,"target_y"
   
,"sector_final"                                        
,"tipocontribuyente"                                   
,"NumeroTrabajadores"                                  
,"MAX_PORC_DEUDA_SOBREGIRO_CUENTA_CORRIENTE_ENTFIN_12M"
,"MAX_CNT_ENTIDADES_SSFF_06M"                          
,"SD_MAX_DIAS_MORA_SSFF_06M"                           
,"CAT_ENTFIN_PRINCIPAL_01M"                            
,"CAT_PRODUCTOS_SSFF_01M"                              
,"MAX_X_CLASIF_12M"                                    
,"ANTIGUEDAD_RCC_01M"
,"EF_VAR_VENTAS_2a"                                    
,"EF_VAR_INMUEBLE_MAQ_EQUIPO_2a"                       
,"EF_DIF_PROMEDIO_PAGOS_DIAS_2a"                       
,"EF_ROTACION_INVENTARIOS_1a"                          
,"EF_COBERTURA_SERVICIO_DEUDA_1a"                      
,"EF_ActivosCirculante_PasivoCirculante_1a"            
,"EF_Cajasbancos_PasivoExigible_1a"                    
,"EF_AUDITADO_1_PROMEDIO_COBRANZA_DIAS_1a"   
)

str(train[,selected])

bins <- 
  woebin(select(train[,selected],
                 -periodo
                
   )
         
       ,y ='target_y', 
       #min_perc_fine_bin=0.02, # How many bins to cut initially into
       min_perc_coarse_bin=0.05,  # Minimum percentage per final bin
       stop_limit=0.02, # Minimum information value 
       max_num_bin=6, method='tree')

#GUARDANDO LOS GRAFICOS DE LOS WOE GENERADOS

pdf("03reports/grafica_bivariado_train_30.09.2023.pdf")
woebin_plot(bins)
dev.off() #cierra el proceso de capturar imagenes en pdf


```


```{r, echo=F, eval=F}
# Calculate WoE dataset
train_woe = woebin_ply(train, bins) 
test_woe = woebin_ply(test, bins)
back_woe = woebin_ply(backtest, bins)

dim(train_woe)
dim(test_woe)
dim(back_woe)

```



```{r, eval=F, echo=F}
#==============================
#save train, test, back woe

qsave(train_woe,"01data/train_woe.qs")
qsave(test_woe,"01data/test_woe.qs")
qsave(back_woe,"01data/back_woe.qs")

dim(train_woe)
dim(test_woe)
dim(back_woe)
```



```{r, eval=T, echo=F}
#==============================
#lectura train, test, back woe

train_woe<-qread("01data/train_woe.qs",nthreads=4)
test_woe<-qread("01data/test_woe.qs",nthreads=4)
back_woe<-qread("01data/back_woe.qs",nthreads=4)

train_woe<-as.data.frame(train_woe)
test_woe<-as.data.frame(test_woe)
back_woe<-as.data.frame(back_woe)
```


## 3.2. Bivariado {.sectionFormat .tabset .tabset-fade .tabset-pills}


### sector_final
```{r, message=F, error=F, warning=F}
woebin_plot(bins$sector_final)
```

### tipocontribuyente
```{r, message=F, error=F, warning=F}
woebin_plot(bins$tipocontribuyente)
```

### NumeroTrabajadores
```{r, message=F, error=F, warning=F}
woebin_plot(bins$NumeroTrabajadores)
```

### MAX_PORC_DEUDA_SOBREGIRO_CUENTA_CORRIENTE_ENTFIN_12M
```{r, message=F, error=F, warning=F}
woebin_plot(bins$MAX_PORC_DEUDA_SOBREGIRO_CUENTA_CORRIENTE_ENTFIN_12M)
```

### MAX_CNT_ENTIDADES_SSFF_06M
```{r, message=F, error=F, warning=F}
woebin_plot(bins$MAX_CNT_ENTIDADES_SSFF_06M)
```

### SD_MAX_DIAS_MORA_SSFF_06M
```{r, message=F, error=F, warning=F}
woebin_plot(bins$SD_MAX_DIAS_MORA_SSFF_06M)
```

### CAT_PRODUCTOS_SSFF_01M
```{r, message=F, error=F, warning=F}
woebin_plot(bins$CAT_PRODUCTOS_SSFF_01M)
```

### MAX_X_CLASIF_12M
```{r, message=F, error=F, warning=F}
woebin_plot(bins$MAX_X_CLASIF_12M)
```


### ANTIGUEDAD_RCC_01M
```{r, message=F, error=F, warning=F}
woebin_plot(bins$ANTIGUEDAD_RCC_01M)
```

### EF_VAR_INMUEBLE_MAQ_EQUIPO_2a
```{r, message=F, error=F, warning=F}
woebin_plot(bins$EF_VAR_INMUEBLE_MAQ_EQUIPO_2a)
```

### EF_DIF_PROMEDIO_PAGOS_DIAS_2a
```{r, message=F, error=F, warning=F}
woebin_plot(bins$EF_DIF_PROMEDIO_PAGOS_DIAS_2a)
```

### EF_COBERTURA_SERVICIO_DEUDA_1a
```{r, message=F, error=F, warning=F}
woebin_plot(bins$EF_COBERTURA_SERVICIO_DEUDA_1a)
```

### EF_Cajasbancos_PasivoExigible_1a
```{r, message=F, error=F, warning=F}
woebin_plot(bins$EF_Cajasbancos_PasivoExigible_1a)
```

### EF_AUDITADO_1_PROMEDIO_COBRANZA_DIAS_1a
```{r, message=F, error=F, warning=F}
woebin_plot(bins$EF_AUDITADO_1_PROMEDIO_COBRANZA_DIAS_1a)
```

## 4 Modelo RL: Modelo final {.sectionFormat .tabset .tabset-fade .tabset-pills}


### Model RL
```{r eval=T, echo=T, message=FALSE}
train_woe$target_y<-as.factor(train_woe$target_y)

#Modelo
model = glm( train_woe$target_y ~ 
               sector_final_woe
              +tipocontribuyente_woe
              +NumeroTrabajadores_woe
              +MAX_PORC_DEUDA_SOBREGIRO_CUENTA_CORRIENTE_ENTFIN_12M_woe
              +MAX_CNT_ENTIDADES_SSFF_06M_woe
              +SD_MAX_DIAS_MORA_SSFF_06M_woe
              +CAT_PRODUCTOS_SSFF_01M_woe
              +MAX_X_CLASIF_12M_woe
              +ANTIGUEDAD_RCC_01M_woe
              +EF_VAR_INMUEBLE_MAQ_EQUIPO_2a_woe
              +EF_DIF_PROMEDIO_PAGOS_DIAS_2a_woe
              +EF_COBERTURA_SERVICIO_DEUDA_1a_woe
              +EF_Cajasbancos_PasivoExigible_1a_woe
              +EF_AUDITADO_1_PROMEDIO_COBRANZA_DIAS_1a_woe

    ,family = binomial(link="logit"), data = train_woe)

#Anova

knitr::kable(vif(model, merge_coef = TRUE), format="simple")

```


### Gini
```{r, eval=T, echo=F, message=F}
#========
# Gini

train_<-auc_gini(muestra=train_woe,modelo=model)
test_<-auc_gini(muestra=test_woe,modelo=model)
back_<-auc_gini(muestra=back_woe,modelo=model)
c<-as.data.frame(rbind(train_,test_,back_))
rownames(c)<-c("train_","test_","back_")
knitr::kable(c, align = "ccc")

```


### Correlación
```{r, eval=T, echo=F, message=F, error=F, warning=F, fig.width=10, fig.height=10}

 selected=c(
   "sector_final_woe"
  ,"tipocontribuyente_woe"
  ,"NumeroTrabajadores_woe"
  ,"MAX_PORC_DEUDA_SOBREGIRO_CUENTA_CORRIENTE_ENTFIN_12M_woe"
  ,"MAX_CNT_ENTIDADES_SSFF_06M_woe"
  ,"SD_MAX_DIAS_MORA_SSFF_06M_woe"
  ,"CAT_PRODUCTOS_SSFF_01M_woe"
  ,"MAX_X_CLASIF_12M_woe"
  ,"ANTIGUEDAD_RCC_01M_woe"
  ,"EF_VAR_INMUEBLE_MAQ_EQUIPO_2a_woe"
  ,"EF_DIF_PROMEDIO_PAGOS_DIAS_2a_woe"
  ,"EF_COBERTURA_SERVICIO_DEUDA_1a_woe"
  ,"EF_Cajasbancos_PasivoExigible_1a_woe"
  ,"EF_AUDITADO_1_PROMEDIO_COBRANZA_DIAS_1a_woe"
 )

aux<-grafico_correlacion(variables=selected, muestra=train_woe)
aux
#ggsave("02plots/plt_corr.png", width = 12, height = 12)

```


### Importancia

```{r, message=F, error=F, warning=F}
plt_importance_logit(model)
#ggsave("02plots/plt_importance.png", width = 8, height = 8)

```

### Gini por periodo

```{r, message=FALSE, fig.width=12, fig.height=5}
#Train&Test
train_woe$prob_m<-predict(model,train_woe,type = "response")
test_woe$prob_m<-predict(model,test_woe,type = "response")
desarrollo<-rbind(train_woe,test_woe)
#mes=sort(unique(train_woe[,c("periodo")]))
mes=c( "201701" ,"201702" ,"201703" ,"201704" ,"201705" ,"201706",
       "201707" ,"201708" ,"201709" ,"201710" ,"201711" ,"201712",
       "201801" ,"201802" ,"201803" ,"201804" ,"201805" ,"201806",
       "201807" ,"201808" ,"201809" ,"201810" ,"201811" ,"201812",
       "201901" ,"201902" ,"201903" ,"201904" ,"201905" ,"201906")

gini <- vector("numeric", 0)
for(i in mes) {
  gini[i]=auc_gini(muestra=subset(desarrollo,desarrollo$periodo==i),modelo=model)[2]
}
gini_desarrollo<-as.data.frame(gini)
#knitr::kable(gini_desarrollo)

#Back
#mes=sort(unique(back_woe[,c("periodo")]))
back_woe$prob_m<-predict(model,back_woe,type = "response")
mes=c("201907", "201908", "201909", "201910", "201911")
gini <- vector("numeric", 0)
#                  
for(i in mes) {
  gini[i]=auc_gini(muestra=subset(back_woe,back_woe$periodo==i),modelo=model)[2]
}
gini_back<-as.data.frame(gini)
#knitr::kable(gini_back)
rm(desarrollo)

gini_mes<-rbind(as.data.frame(gini_desarrollo),as.data.frame(gini_back))
gini_mes<-cbind(data.frame(rownames(gini_mes)),gini_mes)
#rownames(gini_mes) <- NULL
#
#gini_mes<-gini_desarrollo

#Evolucion de Gini
ggplot(gini_mes, aes(x=rownames(gini_mes), y=gini*100, group = 1))+
  geom_point(colour="steelblue", size= 3) +
  geom_line(size=2, colour="steelblue")+
  geom_text(aes(label = gini*100,), 
            size = 4,
            vjust = 1.5,
            colour="black")+
  ylim(0, 100)+
  theme_bw()+
  annotate("text", x= '201907',y= 60, size= 3,
           label="Periodo backtesting"
           ,color="black")+
  labs(y = "%Gini", 
       x = "Periodo",
       title = "Evolución del indicador Gini ")+
  theme(plot.title = element_text(hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5))+
  theme(legend.position = "bottom")


```


## 4.1.Validación: Ordenamiento - muestra backtest


```{r, message=FALSE, eval=T,warning=FALSE, echo=T, fig.width=8, fig.height=5}
#=============================
# Ordenamiento
#

#subset(back_woe,is.na(back_woe$sector_final_woe)==T)
#subset(back_woe,is.na(back_woe$CAT_PRODUCTOS_SSFF_01M_woe)==T)

#=============================
# Imputación
#
back_woe$sector_final_woe<-ifelse(is.na(back_woe$sector_final_woe)==T,-0.04258766
                                   ,back_woe$sector_final_woe)

back_woe$CAT_PRODUCTOS_SSFF_01M_woe<-ifelse(is.na(back_woe$CAT_PRODUCTOS_SSFF_01M_woe)==T,
                                            -0.620615550
                                   ,back_woe$CAT_PRODUCTOS_SSFF_01M_woe)

# Tablas
tabla_validacion(muestra=back_woe,n_division=10,modelo=model)
tabla_validacion_plot(muestra=back_woe,n_division=10,modelo=model)

```

###  AUC y KS
```{r, message=F, error=F, echo=T, eval=T}
ROCit_obj <- rocit(score=back_woe$prob_m,class=back_woe$target_y)
plot(ROCit_obj)
ksplot(ROCit_obj)
```

### Distribución por probabilidad y target
```{r, eval=T, echo=F}

ggplot(back_woe, aes(prob_m))+
geom_histogram(bins=100, color="white", fill="steelblue")+
facet_grid(rows=vars(target_y))+
theme_gray()+
labs(y = "Cantidad", 
       x = "Probabilidad",
       title = "Distribución por probabilidad y target"
       )+
theme(plot.title = element_text(hjust = 0.5))+
scale_color_manual("green", "yellow", "red")

```

